\documentclass{article}
\usepackage{xcolor}
\usepackage{fontspec}
\setmainfont{Noto Serif}
\setsansfont{Noto Sans}
\setmonofont{Noto Sans Mono}
\usepackage{xparse}
\usepackage{gb4e}
\noautomath
\usepackage{xurl}
\newcommand\surl[1]{{\footnotesize\noindent Source Reference}\\\url{#1}}

%=======================
\usepackage{polyglossia}
\setmainlanguage{english}
\setotherlanguage[variant=ancient]{greek}
\newfontfamily\greekfont[Script=Greek,Renderer=HarfBuzz]{Noto Serif}%{Linux Libertine O}


\newcommand\pkvstrong[1]{\mfsgetapropkv{strong}{#1}}
\newcommand\pkvnabeng[1]{\mfsgetapropkv{nabeng}{#1}}
\newcommand\pkvtest[1]{\fbox{#1}}


\ExplSyntaxOn



		\cs_generate_variant:Nn 
			\seq_gset_split:Nnn 
			{ cno }

		\cs_generate_variant:Nn 
			\seq_gset_split:Nnn 
			{ coo }

		\cs_generate_variant:Nn 
			\seq_item:Nn 
			{ cn }

		\cs_generate_variant:Nn 
		\regex_match:nnT
		{ nvT }
		
		
\tl_new:N \g_fc_namespace_tl % O-
\int_new:N \g_gloss_licount_int
\int_new:N \g_gloss_wordcount_int
\int_new:N \g_gloss_wordsonthisline_int
\tl_new:N \g_fc_wnamespace_tl
\tl_new:N \g_fc_mylinenum_tl
\tl_new:N \g_gloss_currentline_tl
\tl_new:N \g_gloss_currentword_tl
\tl_new:N \g_gloss_parentline_tl




\tl_new:N \g_gloss_preamble_tl
\tl_new:c { l_gloss_cline1_tl }
\tl_new:c { l_gloss_cline2_tl }
\tl_new:c { l_gloss_cline3_tl }

\keys_define:nn { gloss }
{
preamble .tl_set:N = \g_gloss_preamble_tl,
addca .tl_set:c = { l_gloss_cline1_tl },
addcb .tl_set:c = { l_gloss_cline2_tl },
addcc .tl_set:c = { l_gloss_cline3_tl },
}


%****************************************************
%* procedures
%****************************************************
%------------------
\tl_new:N \g__gloss_intoseqname_tl
\tl_new:N \g__gloss_fromseqname_tl
\int_new:N \g__gloss_clausecount_int
\int_new:N \g__gloss_clauseloop_int
\tl_new:N \g__gloss_clauseloop_tl

\int_new:N \g__gloss_basenamecount_int
\int_new:N \g__gloss_basenameloop_int
\tl_new:N \g__gloss_basenameloop_tl

\int_new:N \g__gloss_wordloop_int
\tl_new:N \g__gloss_wordloop_tl

\int_new:N \g__gloss_maxlinecount_int
\int_new:N \g__gloss_maxwordcount_int

\bool_new:N \g__gloss_vpar_bool
\int_new:N \g__gloss_vpar_int

\bool_new:N \g__gloss_keepdotpos_bool
\bool_set_true:N \g__gloss_keepdotpos_bool

\bool_new:N \g__gloss_numberedwords_bool
\bool_set_false:N \g__gloss_numberedwords_bool

\bool_new:N \g__gloss_glosstrans_bool
\bool_new:N \g__gloss_formattedvbox_bool


	% 1=from seq base name
\tl_new:N \g__gloss_frombasename_tl
	% 2=base name loop start
\int_new:N \g__gloss_basenamestart_int
	% 3=base name loop finish
\int_new:N \g__gloss_basenamefinish_int
	% 4=words seq 1 (words to box)
\tl_new:N \g__gloss_wordstobox_tl




%-----------------------------
	\cs_set:Npn \gl_functexttransall:n #1 { 

	\tl_set:Nx
				\l_tmpc_tl
			{
														\seq_item:cn
																{ g_gloss_current_seq }
																{ #1 }

			}




				
	%		:command;	 > \command	
		\regex_replace_all:nnN
				{ (\:)(\w+)(;) }
				{ \c{\2}  }
				\l_tmpc_tl
	
%%	%		:command	> 	\command
%%		\regex_replace_all:nnN
%%				{ (\:)(\w+) }
%%				{ \c{\2}  }
%%				\l_tmpc_tl
				
										\tex_space:D
										
%										\\
								\int_compare:nNnTF
								  { #1 } = { 2 }
								  {
								   \tl_if_empty:NTF
								  		\g_gloss_parentline_tl 
								  		{ } %do nothing - line is empty
								  		{ \\ }
								  }
								  { \\ }		
										
										
	\tl_use:N
				\l_tmpc_tl
}


%-----------------------------
	\cs_set:Npn \gl_functexttrans:n #1 { 

	\tl_set:Nx
				\l_tmpc_tl
			{
														\seq_item:cn
																{ g_gloss_glossglosses \int_use:N \g__gloss_maxlinecount_int _seq }
																{ #1 }

			}

%
	%		::command!arg;	 > \command	{arg}
		\regex_replace_all:nnN
				{ (\:\:)(\w+)(\!)(\w+)(;) }
				{ \c{\2} \cB\{ \4 \cE\}  }
				\l_tmpc_tl


	%		word::command;	 > \command	{word}
		\regex_replace_all:nnN
				{ (\S+)(\:\:)(\S+)(;) }  %Greek
				{ \c{\3} \cB\{ \1 \cE\}  }
				\l_tmpc_tl

				
	%		:command;	 > \command	
		\regex_replace_all:nnN
				{ (\:)(\w+)(;) }
				{ \c{\2}  }
				\l_tmpc_tl
	
%%	%		:command	> 	\command
%%		\regex_replace_all:nnN
%%				{ (\:)(\w+) }
%%				{ \c{\2}  }
%%				\l_tmpc_tl
				
										\tex_space:D
										\\
	\tl_use:N
				\l_tmpc_tl
}





%------------------
	\cs_set:Npn \gl_funcgtoutbox:  { 
 	% ===============================
	% The dim is: 
	%							{ g_gloss_wordwidth\g__gloss_wordloop_tl _dim }

 	% ===============================
  % set each nth word to widest width

%\int_show:N \g__gloss_basenamecount_int


	\int_set:Nn
			\l_tmpa_int
			{ 1 }
 	\int_do_until:nNnn % for each line
 		{ \l_tmpa_int } > { \g__gloss_basenamecount_int } 
 					{
	
 	 				\int_set:Nn
					\l_tmpb_int
					{ 1 }
 					\int_do_until:nNnn % for each word
 					{ \l_tmpb_int } > { \seq_count:c
				{ g_gloss_ \g_fc_namespace_tl \g__gloss_intoseqname_tl _seq } } 	%%%
 				{
%---start
\tl_gset:Nx \g_gloss_currentline_tl { \int_use:N \l_tmpa_int }
\tl_gset:Nx \g_gloss_currentword_tl { \int_use:N \l_tmpb_int }



\box_gset_wd:cn
			{ g_gloss_line\g_gloss_currentline_tl word\g_gloss_currentword_tl _box }
			{ 
					\dim_use:c
							{ g_gloss_wordwidth\g_gloss_currentword_tl _dim }
			}
% output: wordforword:
	\box_use:c %=
			{ g_gloss_line\g_gloss_currentline_tl word\g_gloss_currentword_tl _box }
	\tex_space:D %=
	\tex_space:D %=

			
				\int_incr:N 
						\l_tmpb_int

					} 	
					
% output: trans lines:
	\seq_set_eq:Nc
	  \g_gloss_current_seq 
	  { g_gloss_glossglosses\g_gloss_currentline_tl _seq }
	 \tl_gset:Nx
	     \g_gloss_parentline_tl 
	     {
	        \seq_item:cn
	        { g_gloss_glossglosses\g_gloss_currentline_tl _seq }
	        { 1 }
	     }
		\gl_functranoutall:

			\\ %=
						\int_incr:N 
								\l_tmpa_int
		} 	

}




%------------------
	\cs_set:Npn \gl_funcregexmeta:  { 
% regex meta commands

% line1 commands
		\tl_if_empty:cF { l_gloss_cline1_tl }
		{  
		\int_compare:nNnT
								  { \g__gloss_basenameloop_int } = { 1 }
								  {

		\regex_replace_all:nnN
				{ (\S+) }
				{ \c{\u{l_gloss_cline1_tl}} \cB\{ \0 \cE\} }
				\l_tmpc_tl
												}% end line1
			}% end has value
%---
% line2 commands
		\tl_if_empty:cF { l_gloss_cline2_tl }
		{  
		\int_compare:nNnT
								  { \g__gloss_basenameloop_int } = { 2 }
								  {
		\regex_replace_all:nnN
				{ (\S+) }
				{ \c{\u{l_gloss_cline2_tl}} \cB\{ \0 \cE\} }
				\l_tmpc_tl
												}% end line2
			}% end has value
%---
% line3 commands
		\tl_if_empty:cF { l_gloss_cline3_tl }
		{  
		\int_compare:nNnT
								  { \g__gloss_basenameloop_int } = { 3 }
								  {
		\regex_replace_all:nnN
				{ (\S+) }
				{ \c{\u{l_gloss_cline3_tl}} \cB\{ \0 \cE\} }
				\l_tmpc_tl
												}% end line3
			}% end has value
%---



		\bool_if:NTF
		\g__gloss_keepdotpos_bool
		{
%    .text  >  .{\mfsposformat text}
		\regex_replace_all:nnN
				{ (\.)(\w+) }
				{ \1 \cB\{ \c{mfsposformat} \2 \cE\} }
				\l_tmpc_tl
		}
		{
%    .text  >  {\mfsposformat text}
		\regex_replace_all:nnN
				{ (\.)(\w+) }
				{ \cB\{ \c{mfsposformat} \2 \cE\} }
				\l_tmpc_tl
			}
			

	%		::command!arg;	 > \command	{arg}
		\regex_replace_all:nnN
				{ (\:\:)(\w+)(\!)(\w+)(;) }
				{ \c{\2} \cB\{ \4 \cE\}  }
				\l_tmpc_tl


	%		word::command;	 > \command	{word}
		\regex_replace_all:nnN
				{ (\w+)(\:\:)(\w+)(;) }
				{ \c{\3} \cB\{ \1 \cE\}  }
				\l_tmpc_tl
			

			
%		:command;	 > \command	
		\regex_replace_all:nnN
				{ (\:)(\w+)(;) }
				{ \c{\2}  }
				\l_tmpc_tl
				
%		:command	> 	\command
		\regex_replace_all:nnN
				{ (\:)(\w+) }
				{ \c{\2}  }
				\l_tmpc_tl
				

		\regex_match:nvT
				{ \+ }
				{ l_tmpc_tl } 
				{ \int_set_eq:NN 
							\g__gloss_vpar_int 
							\g__gloss_wordloop_int }
				
		\regex_replace_all:nnN
				{ \+ }
				{  }
				\l_tmpc_tl


}




%------------------
	\cs_set:Npn \gl_funcstacktheboxes:  { 
% stack the boxes

\tex_space:D %=



% outer loop
	\int_set:Nn
			\g__gloss_clauseloop_int
			{ 1 }

	\int_set:Nn
			\g__gloss_wordloop_int
			{ 1 }

 	\int_do_until:nNnn 
 		{ \g__gloss_wordloop_int } > { \seq_count:c
				{ g_gloss_ \g_fc_namespace_tl \g__gloss_intoseqname_tl _seq } } 
 	 {
	
	

% loop start

\int_set:Nn 
		\g__gloss_basenamecount_int
		{ 
				\int_use:N \g__gloss_basenamefinish_int	
		}	
	\int_set:Nn
			\g__gloss_basenameloop_int
			{ \int_use:N \g__gloss_basenamestart_int }

\vbox_set_top:Nn
		\l__vpair_box
		{ %^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				% stack all the words			
 	\int_do_until:nNnn 
 		{ \g__gloss_basenameloop_int } > { \g__gloss_basenamecount_int } 

 	 {

\tl_gset:Nx
	 \g__gloss_fromseqname_tl 
	 { 
	 		\tl_use:N \g__gloss_frombasename_tl 
	 		\int_use:N \g__gloss_basenameloop_int
	 }
	 
\tl_gset:Nx \g__gloss_intoseqname_tl 
		{ 
	 		\tl_use:N \g__gloss_frombasename_tl 
	 		\int_use:N \g__gloss_basenameloop_int
			\tl_use:N \g__gloss_wordstobox_tl
		}

\int_gset:Nn 
		\g__gloss_clausecount_int
		{ 
				\seq_count:c
						{ g_gloss_ \g_fc_namespace_tl \g__gloss_intoseqname_tl _seq }		
		}


\tl_gset:Nx
		\g__gloss_wordloop_tl
		{ \int_use:N \g__gloss_wordloop_int }

%\vskip-.32cm\hskip.01cm\vtop{
	\box_use:c
{ g_gloss_ \g_fc_namespace_tl \g__gloss_intoseqname_tl \g__gloss_clauseloop_tl\g__gloss_wordloop_tl _box }
%}

		%============================
		\int_incr:N
					\g__gloss_basenameloop_int
		} % loop finish
		
		} %^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

  %store the width of the vbox:		
		\dim_set:Nn \l_tmpa_dim {\box_wd:N \l__vpair_box}

	\cs_if_free:cT
			{ g_gloss_wordwidth\g__gloss_wordloop_tl _dim }
			{ \dim_new:c
					{ g_gloss_wordwidth\g__gloss_wordloop_tl _dim }
				}
		
		\dim_gset_eq:cN
					{ g_gloss_wordwidth\g__gloss_wordloop_tl _dim }
					\l_tmpa_dim
		
		
%if stacked:		
		\bool_if:NF
		\g__gloss_glosstrans_bool
		{ 
\hbox_set:Nn
		\l__hunit_box
		{
				\bool_if:NTF
						\g__gloss_formattedvbox_bool
							{
								\colorbox{blue!12}{ % \phantom{yl}
										\box_use:N %=
											\l__vpair_box
										} %end colorbox
								} %end true
								{ %false
										\box_use:N %=
											\l__vpair_box
								} %end false
					} 	% end box_set



		\box_use:N %=
				\l__hunit_box 
				

						\int_compare:nNnTF
							{ \g__gloss_vpar_int  } = { \g__gloss_wordloop_int }
							{
									\\ % insert new line if xxx+ was in the wfw line
									\int_set:Nn \g__gloss_vpar_int { 0 }
							}
				{
							\tex_space:D %=
							\tex_space:D %=		
				}

			} %end if-stacked				
							 


				
		\int_incr:N
					\g__gloss_wordloop_int
		} % outer loop finish

}

\seq_new:N \g_gloss_current_seq
%------------------
	\cs_set:Npn \gl_functranoutall:  { 
 			\int_compare:nNnT
							{ \seq_count:c
									{ g_gloss_current_seq }
%									{ g_gloss_glossglosses1_seq }
									} > { 1 }
							{
%								\smallskip
								\int_step_function:nnnN
										{ 2 } 
										{ 1 } 
										{ \seq_count:c
									{ g_gloss_current_seq } } 
										  \gl_functexttransall:n
											}
	 
}





%------------------
	\cs_set:Npn \gl_functranout:  { 
 			\int_compare:nNnT
							{ \seq_count:c
									{ g_gloss_glossglosses \int_use:N \g__gloss_maxlinecount_int _seq }
							 } > { 1 }
							{
								\smallskip
								\int_step_function:nnnN
										{ 2 } 
										{ 1 } 
										{ \seq_count:c
									{ g_gloss_glossglosses \int_use:N \g__gloss_maxlinecount_int _seq } } 
										  \gl_functexttrans:n
											}
	 
}


%------------------
	\cs_set:Npn \gl_funcboxall:nnnn #1#2#3#4 { 
	% 1=from seq base name
	% 2=base name loop start
	% 3=base name loop finish
	% 4=words seq 1 (words to box)
	
	% 1=from seq base name
\tl_gset:Nx \g__gloss_frombasename_tl { #1 }
	% 2=base name loop start
\int_gset:Nn\g__gloss_basenamestart_int { #2 }
	% 3=base name loop finish
\int_gset:Nn \g__gloss_basenamefinish_int  { #3 }
	% 4=words seq 1 (words to box)
\tl_gset:Nx \g__gloss_wordstobox_tl { #4 }
	
	
	
	
% outer loop
\int_set:Nn 
		\g__gloss_basenamecount_int
		{ 
				#3		
		}	
	\int_set:Nn
			\g__gloss_basenameloop_int
			{ #2 }
			
 	\int_do_until:nNnn 
 		{ \g__gloss_basenameloop_int } > { \g__gloss_basenamecount_int } 
 	 {
	
	
\tl_set:Nx
	 \g__gloss_fromseqname_tl 
	 { 
	 		#1 
	 		\int_use:N \g__gloss_basenameloop_int
	 }
	 
\tl_set:Nx \g__gloss_intoseqname_tl 
		{ 
	 		#1 
	 		\int_use:N \g__gloss_basenameloop_int
			#4
		}


\int_set:Nn 
		\g__gloss_clausecount_int
		{ 
				\seq_count:c
						{ g_gloss_ \g_fc_namespace_tl \g__gloss_intoseqname_tl _seq }		
		}

% loop start

	\int_set:Nn
			\g__gloss_clauseloop_int
			{ 1 }

	\int_set:Nn
			\g__gloss_wordloop_int
			{ 1 }
 	\int_do_until:nNnn 
 		{ \g__gloss_wordloop_int } > { \seq_count:c
				{ g_gloss_ \g_fc_namespace_tl \g__gloss_intoseqname_tl _seq } } 
 	 {

%---
			\int_compare:nNnT
							{ \g__gloss_wordloop_int } > { \g__gloss_maxwordcount_int }
							{
				 	 				\int_set:Nn
											\g__gloss_maxwordcount_int
											{ \g__gloss_wordloop_int }
					}
%---

\tl_set:Nx
		\g__gloss_basenameloop_tl
		{ \int_use:N \g__gloss_basenameloop_int }


\tl_set:Nx
		\g__gloss_wordloop_tl
		{ \int_use:N \g__gloss_wordloop_int }

\cs_if_free:cT
		{ g_gloss_ \g_fc_namespace_tl \g__gloss_intoseqname_tl \g__gloss_clauseloop_tl\g__gloss_wordloop_tl _box }
		{ \box_new:c
				{ g_gloss_ \g_fc_namespace_tl \g__gloss_intoseqname_tl \g__gloss_clauseloop_tl\g__gloss_wordloop_tl _box }
		}
%---

\cs_if_free:cT
		{ g_gloss_line\g__gloss_basenameloop_tl word\g__gloss_wordloop_tl _box }
		{ \box_new:c
				{ g_gloss_line\g__gloss_basenameloop_tl word\g__gloss_wordloop_tl _box }
		}



	\tl_gset:Nx
				\l_tmpc_tl
			{
				\seq_item:cn
							{ g_gloss_ \g_fc_namespace_tl \g__gloss_intoseqname_tl  _seq }
							{ \int_use:N \g__gloss_wordloop_int }
				}
				
				
%-------------------------------------------
%vvv
		\gl_funcregexmeta:


					\tl_put_right:Nn
							\l_tmpc_tl
							{ \strut } % for even coloured stack boxes

				
	\hbox_gset:cn 
			{ g_gloss_ \g_fc_namespace_tl \g__gloss_intoseqname_tl \g__gloss_clauseloop_tl\g__gloss_wordloop_tl _box }
			{
			

					\int_case:nnTF { \g__gloss_basenameloop_int }
					{
					{ 1 } { \glfirstlineformat }
					{ 2 } { \glsecondlineformat }
					{ 3 } { \glthirdlineformat }
					{ 4 } { \glfourthlineformat }
					{ 5 } { \glfifthlineformat }
					{ 6 } { \glsixthlineformat }					
							} { % true
					    %
					}
					{ } % false


					\tl_use:N
							\l_tmpc_tl
							
					\bool_if:NT
						\g__gloss_numberedwords_bool
						{
							\group_begin:
							\upshape
							\normalcolor
							\textsuperscript {	\int_use:N \g__gloss_wordloop_int }
							\group_end:
							}
	
			}

	\box_set_eq:cc 
{ g_gloss_line\g__gloss_basenameloop_tl word\g__gloss_wordloop_tl _box }
			{ g_gloss_ \g_fc_namespace_tl \g__gloss_intoseqname_tl \g__gloss_clauseloop_tl\g__gloss_wordloop_tl _box }


		%============================
		
		\int_incr:N
					\g__gloss_wordloop_int
					
		} % loop finish


		\int_incr:N
					\g__gloss_basenameloop_int
					
		} % outer loop finish


%+++++++++++++++++++++++++
\gl_funcstacktheboxes:


%+++++++++++++++++++++++++
	\bool_if:NT
		\g__gloss_glosstrans_bool
		{ 
				%output (all) trans:
				\gl_funcgtoutbox:
			}				


% :\g_gloss_glossglosses4_seq
% if itemcount > 1 then translation(s)
% \g__gloss_maxlinecount_int


	\bool_if:NF
		\g__gloss_glosstrans_bool
		{ 
				%output the (last line) trans:
				\gl_functranout:
			}				
}




%------------------
	\cs_set:Npn \gl_funcsplitloopseq:nnnnn #1#2#3#4#5 { 
	% 1=from seq base name
	% 2=base name loop start
	% 3=base name loop finish
	% 4=by what
	% 5=into seq
	
% outer loop
\int_set:Nn 
		\g__gloss_basenamecount_int
		{ 
				#3		
		}	
	\int_set:Nn
			\g__gloss_basenameloop_int
			{ #2 }
			
 	\int_do_until:nNnn 
 		{ \g__gloss_basenameloop_int } > { \g__gloss_basenamecount_int } 
 	 {
	
	
\tl_set:Nx
	 \g__gloss_fromseqname_tl 
	 { 
	 		#1 
	 		\int_use:N \g__gloss_basenameloop_int
	 }
	 
\tl_set:Nx \g__gloss_intoseqname_tl 
		{ 
	 		#1 
	 		\int_use:N \g__gloss_basenameloop_int
			#5 
		}


\int_set:Nn 
		\g__gloss_clausecount_int
		{ 
				\seq_count:c
						{ g_gloss_ \g_fc_namespace_tl \g__gloss_fromseqname_tl _seq }		
		}

% loop start

	\int_set:Nn
			\g__gloss_clauseloop_int
			{ 1 }
 	\int_do_until:nNnn 
 		{ \g__gloss_clauseloop_int } > { \g__gloss_clausecount_int } 
 	 {

\tl_set:Nx
		\g__gloss_clauseloop_tl
		{ \int_use:N \g__gloss_clauseloop_int }

\cs_if_free:cT
		{ g_gloss_ \g_fc_namespace_tl \g__gloss_intoseqname_tl \g__gloss_clauseloop_tl _seq }
		{ \seq_new:c
				{ g_gloss_ \g_fc_namespace_tl \g__gloss_intoseqname_tl \g__gloss_clauseloop_tl _seq }
		}

	\seq_gclear:c 
		{ g_gloss_ \g_fc_namespace_tl \g__gloss_intoseqname_tl \g__gloss_clauseloop_tl _seq }

			\exp_args:Nnnx
	\seq_gset_split:coo 
		{ g_gloss_ \g_fc_namespace_tl \g__gloss_intoseqname_tl \g__gloss_clauseloop_tl _seq }
			{ #4 } % separator
			{ 
				\seq_item:cn
							{ g_gloss_ \g_fc_namespace_tl \g__gloss_fromseqname_tl  _seq }
							{ \int_use:N \g__gloss_clauseloop_int }
			 }


	%============================
		
		\int_incr:N
					\g__gloss_clauseloop_int
					
		} % loop finish


		\int_incr:N
					\g__gloss_basenameloop_int
					
		} % outer loop finish

}





%------------------
	\cs_set:Npn \gl_funcsplitseq:nnn #1#2#3 { 
	% 1=from seq
	% 2=by what
	% 3=into seq
	
\tl_set:Nx \g__gloss_fromseqname_tl { #1 }
\tl_set:Nx \g__gloss_intoseqname_tl { #3 }

\int_set:Nn 
		\g__gloss_clausecount_int
		{ 
				\seq_count:c
						{ g_gloss_ \g_fc_namespace_tl \g__gloss_fromseqname_tl _seq }		
		}

% loop start

	\int_set:Nn
			\g__gloss_clauseloop_int
			{ 1 }
 	\int_do_until:nNnn 
 		{ \g__gloss_clauseloop_int } > { \g__gloss_clausecount_int } 
 	 {

\tl_set:Nx
		\g__gloss_clauseloop_tl
		{ \int_use:N \g__gloss_clauseloop_int }

\cs_if_free:cT
		{ g_gloss_ \g_fc_namespace_tl \g__gloss_intoseqname_tl \g__gloss_clauseloop_tl _seq }
		{ \seq_new:c
				{ g_gloss_ \g_fc_namespace_tl \g__gloss_intoseqname_tl \g__gloss_clauseloop_tl _seq }
		}

	\seq_gclear:c 
		{ g_gloss_ \g_fc_namespace_tl \g__gloss_intoseqname_tl \g__gloss_clauseloop_tl _seq }

			\exp_args:Nnnx
	\seq_gset_split:coo 
		{ g_gloss_ \g_fc_namespace_tl \g__gloss_intoseqname_tl \g__gloss_clauseloop_tl _seq }
			{ #2 } 
			{ 
				\seq_item:cn
							{ g_gloss_ \g_fc_namespace_tl \g__gloss_fromseqname_tl  _seq }
							{ \int_use:N \g__gloss_clauseloop_int }
			 }

		
		\int_incr:N
					\g__gloss_clauseloop_int
					
		} % loop finish

}







%------------------
	\cs_set:Npn \gl_funcsplit:nnn #1#2#3 { 
	% 1=into seq
	% 2=what
	% 3=by what

\tl_set:Nx \g__gloss_intoseqname_tl { #1 }
\tl_set:Nx \g__gloss_intoseqwhat_tl { #2 }
\tl_set:Nx \g__gloss_intoseqbywhat_tl { #3 }



\cs_if_free:cT
		{ g_gloss_ \g_fc_namespace_tl \g__gloss_intoseqname_tl _seq }
		{ \seq_new:c
				{ g_gloss_ \g_fc_namespace_tl \g__gloss_intoseqname_tl _seq }
		}

	\seq_gclear:c 
		{ g_gloss_ \g_fc_namespace_tl \g__gloss_intoseqname_tl _seq }

%			\exp_args:Nnnx
	\seq_gset_split:coo 
		{ g_gloss_ \g_fc_namespace_tl \g__gloss_intoseqname_tl _seq }
			{ #3 } 
			{ #2 }


\int_set:Nn 
		\g__gloss_maxlinecount_int
		{
			\seq_count:c
				{ g_gloss_ \g_fc_namespace_tl \g__gloss_intoseqname_tl _seq }	
		}

}



%****************************************************
%* main commands
%****************************************************
%--------------------
\NewDocumentCommand { \glinlinesbase } { o m m +m } { 
	% 1=namespace
	% 2=seq
	% 3=sep
	% 4=data

				\IfNoValueTF { #1 } 
						{ \tl_clear:N \g_fc_namespace_tl } 
						{ \tl_gset:Nn \g_fc_namespace_tl { #1 } }

\int_set:Nn \g__gloss_maxlinecount_int { 0 }
	% split into input lines
	\gl_funcsplit:nnn {#2inlines}{#4}{#3}
	% 1=into seq
	% 2=what
	% 3=by what
	\gl_funcsplitseq:nnn 
			{#2inlines}
			{glt}
			{glosses}

	\gl_funcsplitloopseq:nnnnn 
				{glosses}
				{1}
				{
						\int_use:N
							\g__gloss_maxlinecount_int
					}
				{~}
				{words}

\int_set:Nn \g__gloss_maxwordcount_int { 0 }

	\gl_funcboxall:nnnn 
				{glosses}
				{1}
				{
						\int_use:N
							\g__gloss_maxlinecount_int
						}
				{words1}


				

}





%--------------------
\NewDocumentCommand { \glinlines } { s o +m } { 
	% 1==gloss/trans print choice
	% 2==data
    \IfBooleanTF {#1} 
    { \bool_set_true:N  \g__gloss_glosstrans_bool } 
    { \bool_set_false:N  \g__gloss_glosstrans_bool }
    
     
    \IfNoValueF{#2}
    {
    	\keys_set:nn { gloss } { #2 } 
    	\tl_if_empty:NF
    			 \g_gloss_preamble_tl
    	  { \tl_use:N \g_gloss_preamble_tl \\ }
    	}
   
		\glinlinesbase[gloss]{ex2a}{*/}{ #3 }

}


%--------------------
\NewDocumentCommand { \glinlinesnote } { o +m m } { 
	% 1==data
	% 2==note
	
\begin{minipage}[t]{\linewidth-3em-\widthof{(#3)}}
    \IfNoValueF{#1}
    { 
    	\keys_set:nn { gloss } { #1 } 
    	\tl_if_empty:NF
    		 \g_gloss_preamble_tl
    		{ \tl_use:N \g_gloss_preamble_tl \\ }
    	}

			\glinlines{#2}
\end{minipage} 
\hfill
\begin{minipage}[t]{\widthof{(#3)}}
 (#3)
\end{minipage}

}






%--------------------
\NewDocumentCommand { \glfirstlineformat } { } { 
			
}
%--------------------
\NewDocumentCommand { \glsetfirstlineformat } { m } { 
			\renewcommand{\glfirstlineformat}{#1}
}


%--------------------
\NewDocumentCommand { \glsecondlineformat } { } { 
			
}
%--------------------
\NewDocumentCommand { \glsetsecondlineformat } { m } { 
			\renewcommand{\glsecondlineformat}{#1}
}


%--------------------
\NewDocumentCommand { \glthirdlineformat } { } { 
}
%--------------------
\NewDocumentCommand { \glsetthirdlineformat } { m } { 
			\renewcommand{\glthirdlineformat}{#1}
}



%--------------------
\NewDocumentCommand { \glfourthlineformat } { } { 
}
%--------------------
\NewDocumentCommand { \glsetfourthlineformat } { m } { 
			\renewcommand{\glfourthlineformat}{#1}
}



%--------------------
\NewDocumentCommand { \glfifthlineformat } { } { 
}
%--------------------
\NewDocumentCommand { \glsetfifthlineformat } { m } { 
			\renewcommand{\glfifthlineformat}{#1}
}



%--------------------
\NewDocumentCommand { \glsixthlineformat } { } { 
}
%--------------------
\NewDocumentCommand { \glsetsixthlineformat } { m } { 
			\renewcommand{\glsixthlineformat}{#1}
}


%--------------------
\NewDocumentCommand { \glresetlineformats } {  } { 
\glsetfirstlineformat{}
\glsetsecondlineformat{}
\glsetthirdlineformat{}
\glsetfourthlineformat{}
\glsetfifthlineformat{}
\glsetsixthlineformat{}
}


%--------------------
\NewDocumentCommand { \mfspreformat } { } { 
			\makebox[1.2in]{}
}
%--------------------
\NewDocumentCommand { \mfssetpreformat } { m } { 
			\renewcommand{\mfspreformat}{#1}
}
%--------------------
\NewDocumentCommand { \mfsposformat } { } { 
			\scshape
}
%--------------------
\NewDocumentCommand { \mfssetposformat } { m } { 
			\renewcommand{\mfsposformat}{#1}
}



%==============================
%--------------------
\NewDocumentCommand { \mfssetfirstlinefunc} { m } { 
			\tl_gset:cx  { l_gloss_cline1_tl } { #1 }
%					\tl_show:c { l_gloss_cline1_tl }

}




%--------------------
\NewDocumentCommand { \mfskeepdotposon } { } { 
			\bool_gset_true:N \g__gloss_keepdotpos_bool
}

%--------------------
\NewDocumentCommand { \mfskeepdotposoff } { } { 
			\bool_gset_false:N \g__gloss_keepdotpos_bool
}






%--------------------
\NewDocumentCommand { \mfsglosstranson } { } { 
			\bool_gset_true:N \g__gloss_glosstrans_bool
}

%--------------------
\NewDocumentCommand { \mfsglosstransoff } { } { 
			\bool_gset_false:N \g__gloss_glosstrans_bool
}



%--------------------
\NewDocumentCommand { \mfsformattedvboxon } { } { 
			\bool_gset_true:N \g__gloss_formattedvbox_bool
}

%--------------------
\NewDocumentCommand { \mfsformattedvboxoff } { } { 
			\bool_gset_false:N \g__gloss_formattedvbox_bool
}




%--------------------
\NewDocumentCommand { \mfsnumberedwordson } { } { 
			\bool_gset_true:N \g__gloss_numberedwords_bool
}

%--------------------
\NewDocumentCommand { \mfsnumberedwordsoff } { } { 
			\bool_gset_false:N \g__gloss_numberedwords_bool
}



%--------------------
\NewDocumentCommand { \mfsloadwords } { o m +m } { 
% 1=namespace
% 2=line number
% 3=data

				\IfNoValueTF { #1 } 
						{ \tl_clear:N \g_fc_wnamespace_tl } 
						{ \tl_gset:Nn \g_fc_wnamespace_tl { #1 } }


	\cs_if_free:cT
			{ g_fc_line \g_fc_wnamespace_tl #2 _seq }
			{ \seq_new:c
					{ g_fc_line \g_fc_wnamespace_tl #2 _seq } 
			}
	\seq_gclear:c 
			{ g_fc_line \g_fc_wnamespace_tl #2 _seq } 
			\exp_args:Nnnx
	\seq_gset_split:cno 
			{ g_fc_line \g_fc_wnamespace_tl #2 _seq } 
			{ ~ } 
			{ #3 }

%	\seq_show:c 
%			{ g_fc_line \g_fc_wnamespace_tl #2 _seq } 

	\int_gset:Nn
			\g_gloss_wordcount_int
			{
					\seq_count:c 
							{ g_fc_line \g_fc_wnamespace_tl #2 _seq } 
				
			}

% word ``registers''
	\cs_if_free:cT
			{ g_fc_line \g_fc_wnamespace_tl #2 wordcount_int }
			{ \int_new:c
					{ g_fc_line \g_fc_wnamespace_tl #2 wordcount_int } 
			}
	\int_gset:cn
			{ g_fc_line \g_fc_wnamespace_tl #2 wordcount_int }
			{
					\seq_count:c 
							{ g_fc_line \g_fc_wnamespace_tl #2 _seq } 
				
			}


%%%=
%%	\seq_use:cn
%%			{ g_fc_line \g_fc_wnamespace_tl #2 _seq } 
%%			{ | }
%%
%%	\tex_space:D (
%%	\int_use:N
%%			\g_gloss_wordcount_int
%% 	\tex_space:D items for line #2)
}




%--------------------
\tl_new:N \l_tmpc_tl
\tl_new:N \l_tmpd_tl
\tl_new:N \l_texttranslinenum_tl
\tl_new:N \l_texttransline_tl
\int_new:N \l_texttransline_int
\int_new:N \l_texttransloop_int

\NewDocumentCommand { \mfsuseaseql } { o m m } { 
% 1=namespace
% 2=seq name
% 3=sep
%%% 4=data

				\IfNoValueTF { #1 } 
						{ \tl_clear:N \g_fc_namespace_tl } 
						{ \tl_gset:Nn \g_fc_namespace_tl { #1 } }


			\exp_args:Nnnx
	\seq_set_split:Nnn 
		\l_tmpa_seq
			{ ~ }
 {
	\seq_use:cn
			{ g_fc_rwe \g_fc_namespace_tl #2 _seq } 
			{ #3 }
	}

\tl_set:Nn
\l_tmpa_tl
 {
	\seq_use:Nn
		\l_tmpa_seq
			{ ~ }
	}

\tl_use:N
\l_tmpa_tl

}


\NewDocumentCommand { \mfsuseaseqli } { o m m } { 
% 1=namespace
% 2=seq name
% 3=item
%%% 4=data

				\IfNoValueTF { #1 } 
						{ \tl_clear:N \g_fc_namespace_tl } 
						{ \tl_gset:Nn \g_fc_namespace_tl { #1 } }

%=
	\seq_item:cn
			{ g_fc_rwe \g_fc_namespace_tl #2 _seq } 
			{ #3 }


}







\NewDocumentCommand { \mfsloadaseql } { o m m +m } { 
% 1=namespace
% 2=seq name
% 3=sep
% 4=data

				\IfNoValueTF { #1 } 
						{ \tl_clear:N \g_fc_namespace_tl } 
						{ \tl_gset:Nn \g_fc_namespace_tl { #1 } }


	\cs_if_free:cT
			{ g_fc_rwe \g_fc_namespace_tl #2 _seq }
			{ \seq_new:c
					{ g_fc_rwe \g_fc_namespace_tl #2 _seq } 
			}
			
	\seq_gclear:c 
			{ g_fc_rwe \g_fc_namespace_tl #2 _seq } 
	\seq_gset_split:cno 
			{ g_fc_rwe \g_fc_namespace_tl #2 _seq } 
			{ #3 } 
			{ #4 }





%-----
	\int_gset:Nn
			\g_gloss_licount_int
			{
					\seq_count:c 
							{ g_fc_rwe \g_fc_namespace_tl #2 _seq } 
				
			}


 	
 	% words:
	\int_set:Nn
			\l_tmpa_int
			{ 1 }
 	\int_do_until:nNnn 
 		{ \l_tmpa_int } > { \g_gloss_licount_int } 
 	 {
% 	 xxx
 	 % split out any translation
	\tl_set:Nx 
			\l_texttranslinenum_tl 	 
			{ \int_use:N \l_tmpa_int }
			
	\cs_if_free:cT
			{ g_fc_texttrans \g_fc_namespace_tl #2\l_texttranslinenum_tl _seq }
			{ \seq_new:c
					{ g_fc_texttrans \g_fc_namespace_tl #2\l_texttranslinenum_tl _seq } 
			}

	\tl_set:Nx 
			\l_texttransline_tl 	 
			{ 
							 		\seq_item:cn
 	 							{ g_fc_rwe \g_fc_namespace_tl #2 _seq } 
 	 							{ \int_use:N \l_tmpa_int }

				}

			
%	\exp_args:NNNx		
	\seq_gset_split:cno 
			{ g_fc_texttrans \g_fc_namespace_tl #2\l_texttranslinenum_tl _seq } 
			{ glt } 
			{ 
				\l_texttransline_tl
			 }
 	 
 	 
 	 % store the text
 	 	\tl_set:Nx 
 	 				\l_tmpb_tl
 	 				{ 
 	 						\seq_item:cn
 	 								{ g_fc_texttrans \g_fc_namespace_tl #2\l_texttranslinenum_tl _seq } 
 	 								{ 1 }

 	 				 }

 	 		\mfsloadwords 	{ \int_use:N \l_tmpa_int 	}{ \tl_use:N \l_tmpb_tl }
			\int_incr:N
					\l_tmpa_int
 	 }


 	% ===============================
 	% box everything: (line,word) coord
	\int_set:Nn
			\l_tmpa_int
			{ 1 }
 	\int_do_until:nNnn % for each line
 		{ \l_tmpa_int } > { \g_gloss_licount_int } 
 	 {
					
					\tl_set:Nx 
							\g_fc_mylinenum_tl					
							{ \int_use:N \l_tmpa_int }

							
							\exp_args:NNx
					\int_set:Nn 
							\g_gloss_wordsonthisline_int
							{
									\seq_count:c
											{ g_fc_line \g_fc_wnamespace_tl \g_fc_mylinenum_tl	 _seq } 
							}

							
 	 				\int_set:Nn
					\l_tmpb_int
					{ 1 }
					


 					\int_do_until:nNnn % for each word
 					{ \l_tmpb_int } > { \int_use:c			{ g_fc_line \g_fc_wnamespace_tl \int_use:N \l_tmpa_int wordcount_int } } 
 	 				{
%---start
\tl_gset:Nx \g_gloss_currentline_tl { \int_use:N \l_tmpa_int }
\tl_gset:Nx \g_gloss_currentword_tl { \int_use:N \l_tmpb_int }

	\cs_if_free:cT
			{ g_gloss_line\g_gloss_currentline_tl word\g_gloss_currentword_tl _box }
			{ \box_new:c
					{ g_gloss_line\g_gloss_currentline_tl word\g_gloss_currentword_tl _box } 
			}
			

	\tl_set:Nx
				\l_tmpc_tl
			{
				\seq_item:cn
						{ g_fc_line \g_fc_wnamespace_tl \g_fc_mylinenum_tl	 _seq } 
						{ \int_use:N \l_tmpb_int }
			}


%vvv
		\regex_replace_all:nnN
				{ (\.)(.) }
				{ \1 \c{mfsposformat} \2 }
				\l_tmpc_tl

	\hbox_gset:cn 
			{ g_gloss_line\g_gloss_currentline_tl word\g_gloss_currentword_tl _box }
			{
				\tl_use:N
							\l_tmpc_tl
			}


%------------------------ end compound gloss
 	 					\int_incr:N 
 	 							\l_tmpb_int
					} 	
		\int_incr:N 
				\l_tmpa_int
		} 	
 	
 	

 	% ===============================
 	
  % find widest box by word number (assumes lines are balanced)
 	 				\int_set:Nn
					\l_tmpb_int
					{ 1 }
 					\int_do_until:nNnn % for each word
 					{ \l_tmpb_int } > { \g_gloss_wordsonthisline_int } 	%%%
 					
 					{
					
							
	\int_set:Nn
			\l_tmpa_int
			{ 1 }
 	\int_do_until:nNnn % for each line
 		{ \l_tmpa_int } > { \g_gloss_licount_int } 
 				{
%---start
\tl_gset:Nx \g_gloss_currentline_tl { \int_use:N \l_tmpa_int }
\tl_gset:Nx \g_gloss_currentword_tl { \int_use:N \l_tmpb_int }

	\cs_if_free:cT
			{ g_gloss_wordwidth\g_gloss_currentword_tl _dim }
			{ \dim_new:c
					{ g_gloss_wordwidth\g_gloss_currentword_tl _dim }
				}


%IF
%\exp_args:xNx
\dim_compare:nNnT
			{
					\box_wd:c
							{ g_gloss_line\g_gloss_currentline_tl word\g_gloss_currentword_tl _box }
			}
			>
			{ 
					\dim_use:c
							{ g_gloss_wordwidth\g_gloss_currentword_tl _dim }
			}
			{
%				SET WORDXWIDTH-EQ
					\dim_set:cn 
								{ g_gloss_wordwidth\g_gloss_currentword_tl _dim }
								{
								\box_wd:c
											{ g_gloss_line\g_gloss_currentline_tl word\g_gloss_currentword_tl _box }

								}				
			}

						\int_incr:N 
								\l_tmpa_int
					} 	
				\int_incr:N 
						\l_tmpb_int



		} 	
 	
  
 	% ===============================
  % set each nth word to widest width

					\tex_space:D \\[-\baselineskip] %=
	\int_set:Nn
			\l_tmpa_int
			{ 1 }
 	\int_do_until:nNnn % for each line
 		{ \l_tmpa_int } > { \g_gloss_licount_int } 
 					{
	\mfspreformat %=									
	
	%+++
	%+++
 	 				\int_set:Nn
					\l_tmpb_int
					{ 1 }
 					\int_do_until:nNnn % for each word
 					{ \l_tmpb_int } > { \g_gloss_wordsonthisline_int } 	%%%
 				{
%---start
\tl_gset:Nx \g_gloss_currentline_tl { \int_use:N \l_tmpa_int }
\tl_gset:Nx \g_gloss_currentword_tl { \int_use:N \l_tmpb_int }

\box_gset_wd:cn
			{ g_gloss_line\g_gloss_currentline_tl word\g_gloss_currentword_tl _box }
			{ 
					\dim_use:c
							{ g_gloss_wordwidth\g_gloss_currentword_tl _dim }
			}
				\int_incr:N 
						\l_tmpb_int

					} 	
						\int_incr:N 
								\l_tmpa_int

		} 	

   	
}


%--------------------
%\int_new:N \l__lineloop_int
\int_new:N \l__wordloop_int
\tl_new:N \g_gloss_nextline_tl
\box_new:N \l__upper_box
\box_new:N \l__lower_box
\box_new:N \l__vpair_box
\box_new:N \l__hunit_box
\NewDocumentCommand { \textglossout } { } { 


 	 				\int_set:Nn
					\l__wordloop_int
					{ 1 }
 					\int_do_until:nNnn % for each word
					{ \l__wordloop_int } > { \int_use:c			{ g_fc_line \g_fc_wnamespace_tl 1wordcount_int } }
 				{
%---start
\tl_gset:Nx \g_gloss_currentline_tl { 1 }
\tl_gset:Nx \g_gloss_nextline_tl { 2 }
\tl_gset:Nx \g_gloss_currentword_tl { \int_use:N \l__wordloop_int }


\hbox_set:Nn
		\l__upper_box
		{
					\box_use:c %=
								{ g_gloss_line\g_gloss_currentline_tl word\g_gloss_currentword_tl _box }
					} 	

\hbox_set:Nn
		\l__lower_box
		{
					\box_use:c %=
								{ g_gloss_line\g_gloss_nextline_tl word\g_gloss_currentword_tl _box }
					} 	

\vbox_set:Nn
		\l__vpair_box
		{
					\box_use:N %=
								\l__upper_box
					\box_use:N %=
								\l__lower_box
					} 	

\hbox_set:Nn
		\l__hunit_box
		{
					\box_use:N %=
								\l__vpair_box
					} 	




						\int_incr:N 
								\l__wordloop_int

\tex_space:D

\box_use:N
		\l__hunit_box		
\tex_space:D		
			}

}



%--------------------
\NewDocumentCommand { \transout } { o m } { 
% 1 = namespace
%2 = seq name



	\int_set:Nn 
			\l_texttransline_int
			{
\seq_count:c
 	 								{ g_fc_texttrans \g_fc_namespace_tl #22 _seq }
			}
						
			\int_compare:nNnT
							{ \l_texttransline_int } > { 1 }
							{
								%loop through the translations
 	 				\int_set:Nn
					\l_texttransloop_int
					{ 2 }
 					\int_do_until:nNnn % for each translation
 					{ \l_texttransloop_int } > { \l_texttransline_int } 	%%%
					{
						\\ %= translation starts on new line
							\mfspreformat %=									
							\seq_item:cn
 	 								{ g_fc_texttrans \g_fc_namespace_tl #22 _seq }
 	 								{ \l_texttransloop_int }
						
						\int_incr:N
								\l_texttransloop_int
								
					}			
								
								}
   %---
	\cs_if_free:cF
 	 								{ g_fc_texttrans \g_fc_namespace_tl #23 _seq }
		{ 
		
	\int_set:Nn 
			\l_texttransline_int
			{
\seq_count:c
 	 								{ g_fc_texttrans \g_fc_namespace_tl #23 _seq }
			}
						
			\int_compare:nNnT
							{ \l_texttransline_int } > { 1 }
							{
								%loop through the translations
 	 				\int_set:Nn
					\l_texttransloop_int
					{ 2 }
 					\int_do_until:nNnn % for each translation
 					{ \l_texttransloop_int } > { \l_texttransline_int } 	%%%
					{
						\\ %= translation starts on new line
							\mfspreformat %=									
							\seq_item:cn
 	 								{ g_fc_texttrans \g_fc_namespace_tl #23 _seq }
 	 								{ \l_texttransloop_int }
						
						\int_incr:N
								\l_texttransloop_int
								
					}			
								
								}
		
		 } % end 3rd line
}



%--------------------
\NewDocumentCommand { \mfsloadaseq } { o m +m } { 
% 1=namespace
% 2=seq name
% 3=data

				\IfNoValueTF { #1 } 
						{ \tl_clear:N \g_fc_namespace_tl } 
						{ \tl_gset:Nn \g_fc_namespace_tl { #1 } }


	\cs_if_free:cT
			{ g_fc_rwe \g_fc_namespace_tl #2 _seq }
			{ \seq_new:c
					{ g_fc_rwe \g_fc_namespace_tl #2 _seq } 
			}
	\seq_gclear:c 
			{ g_fc_rwe \g_fc_namespace_tl #2 _seq } 
	\seq_gset_split:cno 
			{ g_fc_rwe \g_fc_namespace_tl #2 _seq } 
			{ , } 
			{ #3 }



}

%****************************************************
%*
%****************************************************
%--------------------
\NewDocumentCommand { \mfsloadaprop } { o m +m } { % 1=NS, 2=prop name, 3=data

				\IfNoValueTF { #1 } 
						{ \tl_clear:N \g_fc_namespace_tl } 
						{ \tl_gset:Nn \g_fc_namespace_tl { #1 } }

	\cs_if_free:cT
			{ g_fc_rwe \g_fc_namespace_tl #2 _prop }
			{ \prop_new:c
					{ g_fc_rwe \g_fc_namespace_tl #2 _prop } 
			}
	\prop_gclear:c 
			{ g_fc_rwe \g_fc_namespace_tl #2 _prop } 
	\prop_gset_from_keyval:cn 
			{ g_fc_rwe \g_fc_namespace_tl #2 _prop } 
			{ #3 }

}



%--------------------
\NewDocumentCommand { \mfsgetapropkv } { o m m } { % 1=NS, 2=prop name, 3=key

				\IfNoValueTF { #1 } 
						{ \tl_clear:N \g_fc_namespace_tl } 
						{ \tl_gset:Nn \g_fc_namespace_tl { #1 } }
	\prop_item:cn
			{ g_fc_rwe \g_fc_namespace_tl #2 _prop } 
			{ #3 }
}



\ExplSyntaxOff

\begin{document}



%
%ενG1722 In τωG3588 the έτειG2094 year τωG3588 δευτέρωG1208 second τηςG3588 of the βασιλείαςG932 kingdom Ναβουχοδονόσορ of Nebuchadnezzar, ενυπνιάσθηG1797 dreamed Ναβουχοδονόσορ Nebuchadnezzar ενύπνιονG1798 a dream, καιG2532 and εξέστηG1839 was startled τοG3588 πνεύμα αυτούG4151 his spirit, καιG2532 and οG3588 ύπνος αυτούG5258 his sleep εγένετοG1096 went απ΄G575 from αυτούG1473 him.
%
%\surl{http://biblia-online.pl/Biblia/Septuaginta/Ksiega-Daniela/2/1}

\mfsloadaseql{nab}{*/}{%
εν τω έτει τω δευτέρω της βασιλείας Ναβουχοδονόσορ ενυπνιάσθη Ναβουχοδονόσορ ενύπνιον και εξέστη το πνεύμα αυτού και ο ύπνος αυτού εγένετο απ΄ αυτού
}

\mfsloadaprop{strong}{%
εν=G1722
,τω=G3588
,έτει=G2094
%,τω=G3588 
,δευτέρω=G1208
,της=G3588
,βασιλείας=G932
,Ναβουχοδονόσορ=*
,ενυπνιάσθη=G1797
%,Ναβουχοδονόσορ=*
,ενύπνιον=G1798
,και=G2532
,εξέστη=G1839
,το=G3588 
,πνεύμα=G4151 
,αυτού=G1473
%,και=G2532
,ο=G3588 
,ύπνος=G5258
%,αυτού=G1473
,εγένετο=G1096
,απ΄=G575
%,αυτού=G1473
,test=Y9999
}

\mfsloadaprop{nabeng}{%
εν=in 
,τω=the 
,έτει=year 
%,τω=G3588 
,δευτέρω=second 
,της=of-the 
,βασιλείας=reign
,Ναβουχοδονόσορ=Nebuchadnezzar 
,ενυπνιάσθη=dreamed 
%,Ναβουχοδονόσορ
% Nebuchadnezzar 
,ενύπνιον=a-dream
,και=and 
,εξέστη=was-startled 
,το=the
,πνεύμα=spirit
,αυτού=his
%,και=G2532
% and 
,ο=the
,ύπνος=sleep
%,αυτού=G5258
% his sleep 
,εγένετο=went 
,απ΄=from 
%,αυτού=G1473
% him.
,test=X9999
}


\glsetfirstlineformat{\footnotesize\ttfamily}
\glsetsecondlineformat{\selectlanguage{greek}\color{blue}{\vrule height 12pt depth 6pt width 0pt}}
\glsetthirdlineformat{\small}
\mfsformattedvboxon

\begin{exe}
\ex  
\glinlines[addca=pkvstrong,addcc=pkvnabeng]{%
    εν τω έτει τω δευτέρω της βασιλείας Ναβουχοδονόσορ ενυπνιάσθη Ναβουχοδονόσορ ενύπνιον και εξέστη το πνεύμα αυτού και ο ύπνος αυτού εγένετο απ΄ αυτού
    */     εν τω έτει τω δευτέρω της βασιλείας Ναβουχοδονόσορ ενυπνιάσθη Ναβουχοδονόσορ ενύπνιον και εξέστη το πνεύμα αυτού και ο ύπνος αυτού εγένετο απ΄ αυτού
    */    εν τω έτει τω δευτέρω της βασιλείας Ναβουχοδονόσορ ενυπνιάσθη Ναβουχοδονόσορ ενύπνιον και εξέστη το πνεύμα αυτού και ο ύπνος αυτού εγένετο απ΄ αυτού
}
\end{exe}

\surl{http://biblia-online.pl/Biblia/Septuaginta/Ksiega-Daniela/2/1}

Text adapted slightly

\end{document}



https://tex.stackexchange.com/questions/647186/linguistic-example-with-alternative-gloss-and-translation/647414#647414



https://tex.stackexchange.com/questions/45520/doing-an-interlinear-text/648911#648911
